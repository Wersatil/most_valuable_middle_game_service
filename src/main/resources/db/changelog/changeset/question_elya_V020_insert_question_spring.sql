INSERT INTO question (question_text, answer, author) VALUES
    ('Каковы основные преимущества Spring Framework?', '1. Dependency Injection для тестируемости и слабой связности. 2. AOP для разделения сквозной функциональности. 3. Упрощённое управление транзакциями. 4. Модульность — можно использовать только нужные части. 5. Огромная экосистема проектов (Boot, Cloud, Data). 6. Простое тестирование благодаря архитектуре на POJO.', 'elka'),
    ('Что такое Dependency Injection в Spring?', 'Паттерн проектирования, при котором контейнер Spring создаёт и внедряет зависимости в объекты, вместо того чтобы объекты создавали их самостоятельно через ''new''. Это делает код слабосвязанным, легко тестируемым и гибким. Реализация принципа инверсии управления (IoC).', 'elka'),
    ('Какие способы внедрения зависимостей существуют в Spring?', '1. Через конструктор (рекомендуется) — обеспечивает неизменяемость и полную инициализацию. 2. Через сеттер-методы — для опциональных зависимостей. 3. Через поле с @Autowired (не рекомендуется для production из-за сложности тестирования).', 'elka'),
    ('В чём разница между @Component, @Service, @Repository и @Controller?', 'Все эти стереотипные аннотации создают Spring бины. @Component — универсальная. @Service — для бизнес-логики. @Repository — для слоя доступа к данным (автоматически преобразует исключения БД). @Controller — для обработки HTTP-запросов в MVC.', 'elka'),
    ('Что такое Spring Bean?', 'Объект, жизненным циклом которого управляет контейнер Spring IoC. Spring создаёт, настраивает и внедряет зависимости в бины.', 'elka'),
    ('В чём основное различие между BeanFactory и ApplicationContext?', '1.ApplicationContext расширяет BeanFactory. 2.В BeanFactory ленивая инициализация бинов, а в ApplicationContext - Eager (singleton). ', 'elka'),
    ('Какие области видимости (scope) бинов существуют в Spring?', '1. singleton (один на всё приложение, по умолчанию). 2. prototype (новый экземпляр при каждом запросе). 3. request (один на HTTP-запрос). 4. session (один на HTTP-сессию). 5. application (один на ServletContext). 6. websocket (один на WebSocket-сессию).', 'elka'),
    ('Являются ли singleton-бины потокобезопасными по умолчанию?', 'Нет. Spring управляет только жизненным циклом бина, но не синхронизирует доступ. Если состояние бина изменяемое, программист должен самостоятельно обеспечить потокобезопасность.', 'elka'),
    ('Опишите жизненный цикл Spring Bean.', '1. Создание экземпляра. 2. Внедрение зависимостей. 3. Вызов Aware-интерфейсов (BeanNameAware и др.). 4. BeanPostProcessor.postProcessBeforeInitialization(). 5. @PostConstruct / InitializingBean.afterPropertiesSet(). 6. BeanPostProcessor.postProcessAfterInitialization() (здесь создаются AOP-прокси). 7. Bean готов к использованию. 8. @PreDestroy / DisposableBean.destroy() при уничтожении контекста.', 'elka'),
    ('Какие способы конфигурации Spring приложения существуют?', '1. XML-конфигурация (устаревший, но гибкий способ). 2. Java-based через @Configuration и @Bean (рекомендуется). 3. Annotation-based через @ComponentScan. 4. Properties-файлы с @Value и @ConfigurationProperties.', 'elka'),
    ('В чем основная разница между Spring и Spring Boot?', 'У Spring Boot: 1. Встроенный сервер. 2. Гораздо более быстрый старт. 3. Есть starter-наборы с зависимостями.', 'elka'),
    ('Что такое @SpringBootApplication?', 'Комбинированная аннотация, объединяющая три: 1. @SpringBootConfiguration — отмечает класс как источник конфигурации. 2. @EnableAutoConfiguration — включает механизм автоконфигурации. 3. @ComponentScan — сканирует текущий пакет и подпакеты на наличие компонентов.', 'elka'),
    ('Что такое Spring Security?', 'Фреймворк для аутентификации (кто вы?) и авторизации (что вам можно?). Защищает от уязвимостей (CSRF, XSS, session fixation). Интегрируется с OAuth2, LDAP, базой данных. В Spring Boot 3 / Security 6 используется @EnableMethodSecurity.', 'elka'),
-- Какая-то дюже сложная тема заумным языком   ('Что такое Spring AOP? Основные понятия.', 'Реализация аспектно-ориентированного программирования для модуляризации сквозной функциональности. Aspect — модуль сквозной логики. Advice — код, выполняемый (@Before, @After, @Around). Join Point — точка выполнения (вызов метода). Pointcut — выражение выбора Join Points. Weaving — процесс внедрения аспектов (в Spring — через динамические прокси).', 'elka'),
    ('Что такое Spring Profiles?', 'Механизм для условной конфигурации в зависимости от среды (dev, test, prod). Позволяет активировать разные наборы бинов и свойств через spring.profiles.active. Настройка через @Profile на @Configuration-классе или @Bean-методе.', 'elka'),
    ('Что такое Spring Boot Actuator?', 'Модуль для мониторинга и управления production-приложением. Предоставляет HTTP endpoints: /actuator/health (состояние), /actuator/metrics (метрики), /actuator/env (переменные окружения), /actuator/loggers (управление логгерами).', 'elka'),
    ('Что такое Spring Boot Starter?', 'Готовый набор зависимостей для конкретных задач. Например: spring-boot-starter-web (веб), spring-boot-starter-data-jpa (БД), spring-boot-starter-security (безопасность), spring-boot-starter-test (тесты). Каждый стартер включает все необходимые библиотеки с совместимыми версиями.', 'elka'),
    ('Что такое Spring Cloud?', 'Набор инструментов для микросервисной архитектуры: Spring Cloud Config (централизованная конфигурация), Service Discovery (Eureka), API Gateway, распределённая трассировка (Sleuth/Zipkin), Circuit Breaker (Resilience4j).', 'elka'),
    ('Как реализовать кэширование в Spring?', 'Через аннотации: @Cacheable (кэширует результат метода), @CacheEvict (удаляет из кэша), @CachePut (обновляет кэш). Требуется @EnableCaching. Поддерживает различные реализации: Redis, Ehcache, Caffeine, Hazelcast.', 'elka'),
    ('Что такое Spring Batch?', 'Фреймворк для пакетной обработки больших объёмов данных. Используется для: генерации отчётов, миграции данных, обработки файлов. Основные компоненты: Job, Step, ItemReader, ItemProcessor, ItemWriter.', 'elka'),
    ('Как реализовать асинхронные вызовы в Spring?', 'С помощью аннотации @Async над методом. Метод выполняется в отдельном потоке. Возвращает CompletableFuture для работы с результатом. Требуется @EnableAsync. Не работает на private методы и вызовы внутри одного класса.', 'elka'),
    ('Что такое Spring WebFlux и когда нужно использовать?', 'Реактивный веб-фреймворк в экосистеме Spring, предназначенный для асинхронной и неблокирующей обработки запросов. Аналог MVC. MVC — проще и подходит в 80% случаев, WebFlux — для high-load и реактивных систем', 'elka'),
    ('Как организовать обработку ошибок в Spring REST API?', 'Через @RestControllerAdvice (глобальный обработчик) + @ExceptionHandler (обработка конкретных исключений). Позволяет возвращать структурированные JSON-ошибки с нужным HTTP-статусом. Можно использовать Problem Details API (RFC 7807) в Spring Boot 3.', 'elka'),
    ('Что такое GraalVM Native Image в Spring Boot 3?', 'Технология, позволяющая скомпилировать Spring Boot-приложение в нативный исполняемый файл, который запускается без JVM, почти как обычная программа на C/C++.', 'elka'),
    ('Какие существуют типы propagation транзакций в Spring?', '1. REQUIRED (по умолчанию) — использует существующую или создаёт новую. 2. REQUIRES_NEW — всегда создаёт новую. 3. NESTED — создаёт вложенную savepoint-транзакцию внутри существующей. 4. SUPPORTS — работает, если есть транзакция. 5. NEVER — требует отсутствия транзакции. 6. MANDATORY — требует наличия транзакции.', 'elka'),
    ('Как реализовать retry-логику в Spring?', 'С помощью Spring Retry и аннотаций: @Retryable (повтор при исключениях), @Backoff (задержка между попытками), @Recover (fallback-метод). Требуется @EnableRetry. Поддерживает экспоненциальную задержку и указание исключений для повтора.', 'elka'),
    ('Что такое Circuit Breaker (предохранитель)?', 'Паттерн для устойчивости микросервисов. При частых сбоях вызовов внешнего сервиса переходит в состояние ''разомкнуто'' и вызывает fallback-метод, избегая перегрузки системы. Реализации: Resilience4j, Spring Cloud Circuit Breaker.', 'elka'),
    ('Для чего используется @Value?', 'Для внедрения значений из внешних источников: @Value(''${db.url}'') — из properties-файлов.', 'elka'),
    ('Что такое @ConfigurationProperties?', 'Ато аннотация Spring Boot, которая позволяет типобезопасно привязывать (bind) параметры конфигурации из application.yml / application.properties к Java-классам.', 'elka'),
    ('Какие аннотации валидации используются в Spring?', 'JSR-303/Jakarta Bean Validation: @NotNull, @Size, @Email, @Pattern, @Min, @Max, @NotBlank, @NotEmpty. @Valid — активирует валидацию. @Validated — Spring-версия, поддерживает групповую валидацию и валидацию на уровне класса.', 'elka'),
    ('В чём разница между @Valid и @Validated?', '@Valid - стандартная JSR-303 аннотация, поддерживает каскадную валидацию. @Validated - Spring-расширение, добавляет групповую валидацию и работает на уровне класса сервиса.', 'elka'),
    ('Как работает @Transactional и какие у него атрибуты?', 'Аннотация для декларативного управления транзакциями через AOP. Атрибуты: propagation (распространение), isolation (уровень изоляции), timeout, readOnly, rollbackFor (при каких исключениях делать откат), noRollbackFor. Работает только на public методах.', 'elka'),
    ('Какие аннотации для работы с HTTP есть в Spring MVC?', 'Композитные аннотации: @GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PatchMapping (упрощают @RequestMapping). Также: @RequestParam (параметры запроса), @PathVariable (переменные пути), @RequestBody (тело запроса), @ResponseBody (тело ответа), @ResponseStatus (HTTP-статус).', 'elka'),
    ('Какие аннотации для кэширования в Spring?', '@Cacheable (кэширует результат метода), @CacheEvict (удаляет из кэша), @CachePut (обновляет кэш), @Caching (несколько операций), @CacheConfig (общая конфигурация для класса). Требуют @EnableCaching. Поддерживают ключи через SpEL.', 'elka'),
    ('Что делают @Conditional аннотации в Spring Boot?', 'Устанавливают условия создания бинов. Примеры: @ConditionalOnClass (если класс в classpath), @ConditionalOnProperty(name=''cache.enabled'', havingValue=''true''), @ConditionalOnMissingBean (если бин отсутствует), @ConditionalOnWebApplication (для веб-приложений). Основа auto-configuration.', 'elka'),
    ('Для чего используются @PostConstruct и @PreDestroy?', '@PostConstruct выполняется после внедрения зависимостей, перед использованием бина (аналог InitializingBean.afterPropertiesSet()). @PreDestroy — вызывается перед уничтожением бина.', 'elka'),
    ('В чём разница между @Primary и @Qualifier?', '@Primary указывает бин по умолчанию при неоднозначности внедрения (несколько бинов одного типа). @Qualifier уточняет конкретное имя бина для внедрения. @Primary задаёт приоритет, @Qualifier даёт точный контроль. Можно использовать вместе.', 'elka'),
    ('Назовите популярные аннотации в Spring Security?', '@EnableWebSecurity — включает безопасность. @PreAuthorize, @PostAuthorize — контроль доступа на основе выражений (SpEL). @Secured — ролевой доступ. В Spring Security 6+ используется @EnableMethodSecurity (старый @EnableGlobalMethodSecurity устарел).', 'elka'),
    ('Назовите популярные аннотации в Spring Data JPA?', '@Repository (стереотип DAO, преобразует исключения), @Query (кастомный JPQL или SQL-запрос), @Modifying (для UPDATE/DELETE), @EntityGraph (жадная загрузка связанных сущностей), @Lock (блокировки). Производные query methods: findByName, findByAgeGreaterThan.', 'elka'),
    ('Что такое @SpringBootTest?', 'Аннотация для интеграционных тестов с полным поднятием Spring Boot-контекста. Параметры: webEnvironment (тип окружения), classes (конфигурационные классы). Часто используется с @MockBean, @TestPropertySource, @AutoConfigureMockMvc.', 'elka'),
    ('Как работают @MockBean и @SpyBean?', '@MockBean создаёт Mockito-mock и регистрирует его как Spring-бин (заменяет или добавляет). @SpyBean создаёт spy (частичный mock) на реальном бине. Используются в интеграционных тестах Spring Boot. Автоматически сбрасываются после каждого теста.', 'elka'),
    ('Что делают аннотации @WebMvcTest и @DataJpaTest?', '@WebMvcTest — тестирует только MVC-слой (быстро, без полного контекста). Автоматически настраивает MockMvc. @DataJpaTest — тестирует JPA-слой (настраивает in-memory БД, инжектирует TestEntityManager). Это ''срезовые'' (slice) тесты.', 'elka'),
    ('Что делает @ActiveProfiles в тестах?', 'Активирует указанные Spring-профили для теста. Например, @ActiveProfiles(''test'') для использования тестовой БД и конфигурации. Работает с @SpringBootTest, @WebMvcTest, @DataJpaTest и другими тестовыми аннотациями.', 'elka'),
-- Не совсем по spring backend... спорный вопрос   ('Для чего используется @ModelAttribute?', 'Для добавления атрибута в модель для всех запросов контроллера (например, списки для выпадающих меню). На уровне параметра: связывает данные запроса (форма, параметры) с объектом и добавляет в модель.', 'elka'),
    ('Что такое @JsonView?', 'Аннотация из библиотеки Jackson, используемая в Spring Boot для контроля того, какие поля объекта сериализуются в JSON или десериализуются из JSON. Проще говоря: один и тот же объект можно показывать разным пользователям по-разному без создания множества DTO.', 'elka'),
    ('Что такое @CrossOrigin?', 'Аннотация для разрешения CORS (Cross-Origin Resource Sharing) запросов к контроллеру или методу. Параметры: origins (разрешённые домены), methods (HTTP-методы), maxAge (время кэширования preflight). Глобальная настройка через WebMvcConfigurer.', 'elka'),
    ('Что делает @Profile?', 'Указывает, для каких профилей нужно создать бин или конфигурацию. Например, @Profile(''dev'') создаёт бин только для профиля dev. Профили активируются через spring.profiles.active или переменные окружения.', 'elka'),
    ('Что делает @RefreshScope?', 'Создаёт бин, который может быть ''освежён'' без перезапуска приложения при изменении конфигурации в Spring Cloud Config. Отправка POST на /actuator/refresh пересоздаёт такие бины с новыми значениями @Value.', 'elka'),
    ('Что делает @NonNullApi?', '@NonNullApi на уровне пакета — все параметры и возвращаемые значения не-null по умолчанию. Помогает статическому анализу и взаимодействию.', 'elka'),
    ('Что такое @Projection в Spring Data?', 'Аннотация, которая позволяет создавать интерфейсы или классы для “выборки” части данных из сущностей вместо того, чтобы загружать всю сущность целиком. Пример: @Projection(name = "usernameOnly", types = User.class) public interface UsernameOnly {String getUsername();}', 'elka'),
    ('Что делает @ComponentScan и что такое basePackages?', '@ComponentScan сканирует классы на наличие Spring-аннотаций. Параметр basePackages указывает пакеты для сканирования (по умолчанию - пакет класса с @SpringBootApplication). basePackageClasses - безопасная альтернатива для указания пакетов.', 'elka'),
    ('Что такое @InitBinder?', 'Аннотация в Spring MVC, которая используется для инициализации и настройки WebDataBinder для конкретного контроллера. Проще говоря: с помощью @InitBinder можно управлять, как Spring преобразует данные из запроса в объекты, валидирует их и форматирует поля. (Схема внедрения и использования похожа на Model model)', 'elka'),
    ('Какие основные аннотации используются в Spring Security?', '1. @EnableWebSecurity - включает конфигурацию безопасности. 2. @PreAuthorize, @PostAuthorize - контроль доступа на основе SpEL выражений. 3. @Secured - ролевой доступ. 4. @EnableMethodSecurity - активирует аннотации безопасности на методах. 5. @EnableGlobalMethodSecurity (устарел в Security 6+).', 'elka'),
    ('Что делает аннотация @PreAuthorize в Spring Security?', 'Проверяет права доступа ДО выполнения метода. Использует SpEL выражения. Пример: @PreAuthorize(''hasRole(''ADMIN'') or #userId == authentication.principal.id'')', 'elka'),
    ('Что делает аннотация @PostAuthorize в Spring Security?', 'Проверяет права доступа ПОСЛЕ выполнения метода, может использовать возвращаемое значение. Пример: @PostAuthorize(''returnObject.owner == authentication.name'')', 'elka'),
    ('Что такое @Secured в Spring Security?', 'Упрощённая аннотация для проверки ролей. Пример: @Secured({''ROLE_ADMIN'', ''ROLE_USER''})', 'elka'),
    ('Что такое @EnableMethodSecurity в Spring Security 6+?', 'Заменяет устаревший @EnableGlobalMethodSecurity. Включает поддержку аннотаций @PreAuthorize, @PostAuthorize, @Secured на методах. Требуется для использования метод-уровневой безопасности.', 'elka'),
    ('Что такое Spring Cloud Gateway?', 'API Gateway для маршрутизации, балансировки нагрузки, аутентификации, мониторинга. Альтернатива Netflix Zuul. Работает на Project Reactor (неблокирующий).', 'elka'),
    ('Что такое Spring Cloud Config?', 'Сервис централизованного управления конфигурацией. Хранит настройки в Git, SVN или файловой системе. Поддерживает шифрование, профили, автоматическое обновление (@RefreshScope).', 'elka'),
    ('Что такое Testcontainers и как ее использовать с Spring Boot?', 'Библиотека для запуска Docker-контейнеров в тестах (БД, Kafka, Redis). @Testcontainers + @Container. Позволяет делать интеграционные тесты с реальными сервисами.', 'elka'),
    ('Чем отличается componentModel = ''spring'' от дефолтного Mappers.getMapper()?', 'componentModel=''spring'' создаёт Spring-бин (@Component), внедряется через DI. Mappers.getMapper() — статический фабричный метод, маппер создаётся как синглтон через MapStruct (не управляется Spring).', 'elka'),
    ('Как можно инжектить в маппер другие мапперы и сервисы?', 'Через параметры uses и injectionStrategy: 1. uses = {OtherMapper.class, HelperService.class} — указывает зависимости. 2. injectionStrategy = InjectionStrategy.CONSTRUCTOR — внедрение через конструктор (рекомендуется). 3. @Autowired на полях/конструкторе в реализации.', 'elka'),
    ('В чём разница между @Mapping и @BeanMapping?', '@Mapping настраивает маппинг конкретного поля: source, target, expression, constant. @BeanMapping настраивает поведение всего метода: nullValuePropertyMappingStrategy, ignoreByDefault, qualifiedByName. @BeanMapping — мета-аннотация для метода.', 'elka'),
    ('Что такое nullValuePropertyMappingStrategy в MapStruct?', 'Стратегия обработки null-значений при маппинге: 1. SET_TO_NULL (по умолчанию) — устанавливает null. 2. SET_TO_DEFAULT — устанавливает default-значение (0, false, etc). 3. IGNORE — пропускает поле, оставляя существующее значение.', 'elka'),
    ('Как можно использовать квалифицированные методы (qualifiedByName) в MapStruct?', '1. @Named аннотация на методе-помощнике. 2. @Mapping(qualifiedByName = ''methodName'') на поле. 3. MapStruct вызовет указанный метод для преобразования значения. Полезно для кастомной логики маппинга.', 'elka'),
    ('Что такое injectionStrategy в MapStruct и какие у нее есть варианты?', 'Стратегия внедрения зависимостей: 1. CONSTRUCTOR (рекомендуется) — зависимости через конструктор, бин неизменяемый. 2. FIELD — через инъекцию в поля. 3. SETTER — через сеттеры. Важно при uses с другими мапперами/сервисами.', 'elka'),
    ('Какими способами можно настроить маппинг вложенных объектов в MapStruct?', '1. Автоматически — если типы совместимы. 2. Через @Mapping с указанием пути: @Mapping(source = ''user.address.city'', target = ''city''). 3. Через uses с другим маппером для вложенного типа. 4. expression для кастомной логики.', 'elka'),
    ('Что делает ignoreByDefault = true в @BeanMapping?', 'Игнорирует все поля целевого объекта по умолчанию. Нужно явно указывать @Mapping для полей, которые нужно маппить. Полезно для безопасности — случайно не замаппить лишние поля.', 'elka'),
    ('Как обрабатывать разные имена полей в MapStruct?', 'Через @Mapping: 1. @Mapping(source = ''userName'', target = ''username'') — разные имена. 2. @Mapping(target = ''fullName'', expression = ''java(entity.getFirstName() + " " + entity.getLastName())'') — выражение. 3. constant для константных значений.', 'elka'),
    ('Что такое хуки @BeforeMapping и @AfterMapping в MapStruct?', 'Методы, выполняемые до/после основного маппинга: 1. @BeforeMapping — инициализация, валидация, подготовка данных. 2. @AfterMapping — постобработка, вычисление производных полей, нормализация. Работают как callback-хуки в жизненном цикле маппинга.', 'elka'),
    ('Когда использовать @BeforeMapping в MapStruct?', '1. Инициализация объектов перед маппингом. 2. Валидация входных данных. 3. Установка значений по умолчанию. 4. Подготовка сложных структур данных. Пример: @BeforeMapping default void validate(UserEntity entity) { if (entity == null) return; // валидация }', 'elka'),
    ('Когда использовать @AfterMapping в MapStruct?', '1. Вычисление производных полей (totalPrice = quantity * price). 2. Нормализация данных (trim, case conversion). 3. Установка зависимостей между полями. 4. Логирование результата маппинга. 5. Заполнение технических полей (createdAt, version).', 'elka'),
    ('Можно ли использовать несколько квалификаторов для одного поля в MapStruct?', 'Да, через qualifiedBy (для аннотаций) или qualifiedByName (для имён методов). Можно указывать несколько квалификаторов — MapStruct выберет подходящий метод. Полезно для разных контекстов маппинга.', 'elka');