INSERT INTO question (question_text, answer, author) VALUES
    ('Что такое JVM?', 'JVM (Java Virtual Machine) — это виртуальная машина, которая исполняет байт-код Java. Она отвечает за загрузку классов, верификацию байт-кода, выполнение инструкций, управление памятью (включая garbage collection), обработку исключений и обеспечение безопасности. JVM является частью JRE (Java Runtime Environment), но для разработки нужен JDK. Благодаря JVM достигается платформо-независимость: один и тот же байт-код работает на Windows, Linux, macOS и других системах.', 'EasyNow'),
    ('Что такое объект в Java?', 'Объект — это экземпляр класса, созданный с помощью оператора new. Каждый объект имеет своё состояние (значения полей) и поведение (методы). Объекты в Java хранятся в куче (heap), а ссылки на них — в стеке. Всё в Java (кроме примитивов) является объектами или работает с объектами. Объекты позволяют моделировать реальные сущности в программе.', 'EasyNow'),
--    ('Какие принципы ООП поддерживает Java?', 'Java полностью поддерживает четыре основных принципа объектно-ориентированного программирования: инкапсуляцию (сокрытие данных через модификаторы доступа и геттеры/сеттеры), наследование (через extends), полиморфизм (перегрузка и переопределение методов), абстракцию (через абстрактные классы и интерфейсы). Эти принципы помогают писать чистый, переиспользуемый и поддерживаемый код.', 'EasyNow'),
    ('Что такое наследование в Java?', 'Наследование — это механизм, позволяющий одному классу (подклассу) наследовать поля и методы другого класса (суперкласса) с помощью ключевого слова extends. Оно поддерживает иерархию классов и переиспользование кода. Java поддерживает только одиночное наследование классов (один суперкласс), но множественное — для интерфейсов (implements несколько интерфейсов).', 'EasyNow'),
    ('Что такое полиморфизм в Java?', 'Полиморфизм позволяет работать с объектами разных классов через общий тип (суперкласс или интерфейс). Реализуется двумя способами: перегрузкой методов (compile-time polymorphism) — несколько методов с одним именем, но разными параметрами; и переопределением методов (runtime polymorphism) — подкласс предоставляет свою реализацию метода суперкласса с аннотацией @Override.', 'EasyNow'),
    ('Что такое инкапсуляция в Java?', 'Инкапсуляция — это объединение данных (полей) и методов, работающих с этими данными, в одном классе, с сокрытием внутренней реализации. Достигается с помощью модификаторов доступа (private для полей) и предоставлением публичных геттеров/сеттеров. Это защищает данные от некорректного использования, упрощает поддержку кода и повышает безопасность.', 'EasyNow'),
    ('Что такое абстракция в Java?', 'Абстракция — это процесс скрытия сложных деталей реализации и показа только необходимого интерфейса. В Java реализуется через абстрактные классы (abstract class) и интерфейсы (interface). Пользователь работает только с объявленными методами, не зная, как они реализованы внутри, что упрощает использование и поддержку кода.', 'EasyNow'),
--    ('Что такое конструктор в Java и для чего он нужен?', 'Конструктор — это специальный метод, который вызывается автоматически при создании объекта с помощью new. Он имеет то же имя, что и класс, не возвращает значение и используется для инициализации полей объекта. Может быть перегружен, иметь параметры и вызывать другие конструкторы через this() или super().', 'EasyNow'),
    ('Что происходит, если в классе нет конструктора?', 'Если в классе не объявлен ни один конструктор, компилятор Java автоматически создаёт конструктор по умолчанию (default constructor) без параметров, который просто вызывает конструктор суперкласса (super()). Если же вы объявили хотя бы один конструктор, default больше не создаётся, и вы должны сами обеспечить нужные варианты инициализации.', 'EasyNow'),
    ('Что такое перегрузка методов в Java?', 'Перегрузка методов (method overloading) — это наличие в одном классе нескольких методов с одинаковым именем, но разными списками параметров (количество, тип или порядок). Решение, какой метод вызвать, принимается на этапе компиляции (compile-time polymorphism). Удобно для предоставления разных способов выполнения похожей операции.', 'EasyNow'),
    ('Что такое переопределение методов в Java?', 'Переопределение методов (method overriding) — это когда подкласс предоставляет свою собственную реализацию метода, унаследованного от суперкласса. Метод должен иметь ту же сигнатуру, возвращаемый тип (или ковariantный) и аннотацию @Override. Вызов происходит на этапе выполнения (runtime polymorphism, dynamic dispatch).', 'EasyNow'),
    ('Что такое статический метод и когда его использовать?', 'Статический метод принадлежит классу, а не конкретному объекту. Вызывается через имя класса (Class.method()), не имеет доступа к нестатическим полям и методам. Используется для утилитных операций, не зависящих от состояния объекта (например, Math.sqrt(), фабричные методы, main()).', 'EasyNow'),
--    ('Что такое интерфейс в Java и зачем он нужен?', 'Интерфейс — это полностью абстрактный тип, определяющий контракт (набор методов), который должен реализовать класс. С Java 8 может содержать default- и static-методы. Используется для достижения множественного наследования поведения, абстракции и слабой связанности кода (программирование к интерфейсу).', 'EasyNow'),
--    ('Что такое абстрактный класс в Java?', 'Абстрактный класс — это класс, объявленный с ключевым словом abstract, который не может быть инстанцирован. Может содержать как абстрактные методы (без реализации), так и обычные методы с реализацией, поля и конструкторы. Используется как базовый класс для иерархии, когда нужно общее состояние или частичная реализация.', 'EasyNow'),
    ('В чем разница между абстрактным классом и интерфейсом?', 'Абстрактный класс может иметь состояние (поля экземпляра), конструкторы, методы с реализацией и поддерживает одиночное наследование. Интерфейс до Java 8 имел только абстрактные методы и константы, не имеет состояния, поддерживает множественную реализацию. С Java 8 интерфейсы получили default и static методы, но всё равно не имеют полей экземпляра и конструкторов.', 'EasyNow'),
    ('Что такое generics в Java и зачем они нужны?', 'Generics (обобщения) позволяют создавать классы, интерфейсы и методы с параметрами типов (например, List<String>). Обеспечивают проверку типов на этапе компиляции, устраняют необходимость приведения типов (casting), повышают безопасность кода и читаемость, предотвращая ClassCastException во время выполнения.', 'EasyNow'),
    ('Что такое лямбда-выражения в Java?', 'Лямбда-выражения — это анонимные функции, введённые в Java 8. Синтаксис: (параметры) -> { тело } или (параметры) -> выражение. Используются для реализации функциональных интерфейсов (с одним абстрактным методом), упрощают код, особенно при работе с коллекциями и Stream API, заменяя громоздкие анонимные классы.', 'EasyNow'),
    ('Что такое Stream API в Java?', 'Stream API (java.util.stream) — это функциональный способ обработки коллекций, введённый в Java 8. Stream представляет последовательность элементов, поддерживает промежуточные операции (map, filter, sorted) и терминальные (collect, reduce, forEach). Позволяет писать декларативный, параллелизуемый (parallelStream()) код без изменения исходной коллекции.', 'EasyNow'),
    ('Что такое garbage collection в Java?', 'Garbage collection — автоматический процесс освобождения памяти от объектов, на которые больше нет активных ссылок. GC в JVM использует generational подход (Young и Old generation), алгоритмы вроде mark-and-sweep. Разработчик не управляет памятью вручную (в отличие от C++), что предотвращает утечки и ошибки доступа.', 'EasyNow'),
    ('В чем разница между Comparable и Comparator?', 'Comparable — интерфейс, реализуемый внутри класса для естественного порядка сортировки (метод compareTo). Один на класс. Comparator — внешний интерфейс для кастомной сортировки (метод compare), можно создавать несколько разных компараторов для одного класса.', 'EasyNow'),
    ('Что такое функциональный интерфейс в Java?', 'Функциональный интерфейс — интерфейс с ровно одним абстрактным методом (SAM — Single Abstract Method). Может иметь default и static методы. Аннотация @FunctionalInterface для проверки. Используется для лямбда-выражений и метод-ссылок (Runnable, Consumer, Function, Predicate и др.).', 'EasyNow'),
--    ('Что такое try-with-resources в Java?', 'Try-with-resources (с Java 7) — конструкция для автоматического закрытия ресурсов, реализующих AutoCloseable или Closeable (файлы, сокеты, БД). Синтаксис: try (Resource r = new Resource()) { ... }. Гарантирует вызов close() в finally, даже при исключении, упрощая код и предотвращая утечки.', 'EasyNow'),
    ('Что такое анонимный внутренний класс?', 'Анонимный внутренний класс — безымянный класс, создаваемый на лету для одноразовой реализации интерфейса или расширения класса. Часто использовался до Java 8 для слушателей событий, обработчиков и т.д. Синтаксис: new Interface() { ... реализация ... }.', 'EasyNow'),
    ('Что такое CompletableFuture в Java?', 'CompletableFuture (с Java 8) — мощный класс для асинхронного программирования. Наследует Future, но позволяет цепочечно комбинировать задачи (thenApply, thenCompose, thenCombine, whenComplete), обрабатывать результаты и исключения без явного управления потоками. Упрощает неблокирующий код.', 'EasyNow'),
    ('Что такое Javadoc и как его использовать?', 'Javadoc — инструмент для генерации HTML-документации из специальных комментариев /** ... */ в коде. Использует теги @param, @return, @throws, @author, @since, @see и др. Запускается командой javadoc. Стандартный способ документирования API в Java, особенно в публичных библиотеках и интерфейсах.', 'EasyNow'),
    ('Что предоставляет класс Math в Java?', 'Math — утилитный класс со статическими математическими константами (PI, E) и методами: abs, sin, cos, tan, pow, sqrt, log, min/max, round, floor, ceil, random() и др. Все методы точны, оптимизированы и не требуют создания объекта.', 'EasyNow'),
    ('Для чего класс Runtime в Java?', 'Runtime — singleton-класс для взаимодействия с JVM. Позволяет запускать внешние процессы (exec()), получать информацию о памяти (freeMemory(), totalMemory()), вызывать garbage collection (gc()), завершать приложение (exit(), halt()). Получается через Runtime.getRuntime().', 'EasyNow'),
    ('Иерархия коллекций в Java. Основные интерфейсы', 'Java Collections Framework — это иерархия интерфейсов и классов для работы с группами объектов. Основные интерфейсы: Collection (корневой, содержит базовые методы add, remove, size, contains и т.д.), List (упорядоченная коллекция с дубликатами, доступ по индексу), Set (множество без дубликатов), Queue (очередь для обработки в определённом порядке), Deque (двусторонняя очередь). От Collection также отходит Map (не наследует Collection, но относится к фреймворку; хранит пары ключ-значение). Популярные реализации: ArrayList (List), HashSet/TreeSet/LinkedHashSet (Set), HashMap/TreeMap/LinkedHashMap (Map). Иерархия позволяет программировать к интерфейсам, легко менять реализации.', 'EasyNow'),
    ('Для чего нужны functional interfaces? (Predicate, Consumer, Function, Supplier)', 'Functional interfaces — интерфейсы с одним абстрактным методом (SAM), используются как цель для лямбда-выражений и метод-ссылок в функциональном программировании Java 8+. Основные из java.util.function: Predicate<T> — принимает T, возвращает boolean (для фильтрации, test()); Consumer<T> — принимает T, ничего не возвращает (для действий, accept()); Function<T,R> — принимает T, возвращает R (для преобразования, apply()); Supplier<T> — ничего не принимает, возвращает T (для создания объектов, get()). Они упрощают код при работе со Stream API, коллекциями (forEach, filter, map) и делают его более выразительным и кратким.', 'EasyNow'),
    ('Почему лучше использовать примитивы, а не обёртки, где возможно?', 'Примитивы (int, double, boolean) хранятся напрямую (значение), обёртки (Integer, Double, Boolean) — объекты в heap с overhead (дополнительная память на объект, ссылку). Примитивы быстрее (нет боксинга/анбоксинга, лучше кэшируются), потребляют меньше памяти, не могут быть null (избегают NPE). Обёртки нужны только когда требуется объект: в коллекциях (List<int> невозможно, только List<Integer>), generics, null-значения или методы утилит. В современном Java (с autoboxing) разница меньше, но в высоконагруженном коде и циклах примитивы дают заметный прирост производительности.', 'EasyNow');
--    ('Как работает HashMap? Что такое коллизии?', 'HashMap хранит пары ключ-значение в массиве бакетов. При put(): вычисляется hashCode() ключа, хэш % размер массива даёт индекс бакета. Если бакет пуст — создаётся Entry (ключ, значение, хэш, ссылка на следующий). Если занят — коллизия. До Java 8 коллизии решались цепочкой (linked list), с Java 8 при длине цепочки > 8 превращается в красно-чёрное дерево для O(log n). get() аналогично ищет по хэшу и equals(). Load factor 0.75 — при заполнении массив ресайзится (вдвое). Коллизия — когда разные ключи дают один индекс бакета (из-за хэша). Хороший hashCode() минимизирует коллизии.', 'EasyNow');
