INSERT INTO question (question_text, answer, author) VALUES
    ('Что такое JVM в Java?', 'JVM (Java Virtual Machine) — это виртуальная машина, которая исполняет байт-код Java. Она отвечает за загрузку классов, верификацию байт-кода, выполнение инструкций, управление памятью (включая garbage collection), обработку исключений и обеспечение безопасности. JVM является частью JRE (Java Runtime Environment), но для разработки нужен JDK. Благодаря JVM достигается платформо-независимость: один и тот же байт-код работает на Windows, Linux, macOS и других системах.', 'EasyNow'),
    ('Что такое объект в Java?', 'Объект — это экземпляр класса, созданный с помощью оператора new. Каждый объект имеет своё состояние (значения полей) и поведение (методы). Объекты в Java хранятся в куче (heap), а ссылки на них — в стеке. Всё в Java (кроме примитивов) является объектами или работает с объектами. Объекты позволяют моделировать реальные сущности в программе.', 'EasyNow'),
    ('Какие принципы ООП поддерживает Java?', 'Java полностью поддерживает четыре основных принципа объектно-ориентированного программирования: инкапсуляцию (сокрытие данных через модификаторы доступа и геттеры/сеттеры), наследование (через extends), полиморфизм (перегрузка и переопределение методов), абстракцию (через абстрактные классы и интерфейсы). Эти принципы помогают писать чистый, переиспользуемый и поддерживаемый код.', 'EasyNow'),
    ('Что такое наследование в Java?', 'Наследование — это механизм, позволяющий одному классу (подклассу) наследовать поля и методы другого класса (суперкласса) с помощью ключевого слова extends. Оно поддерживает иерархию классов и переиспользование кода. Java поддерживает только одиночное наследование классов (один суперкласс), но множественное — для интерфейсов (implements несколько интерфейсов).', 'EasyNow'),
    ('Что такое полиморфизм в Java?', 'Полиморфизм позволяет работать с объектами разных классов через общий тип (суперкласс или интерфейс). Реализуется двумя способами: перегрузкой методов (compile-time polymorphism) — несколько методов с одним именем, но разными параметрами; и переопределением методов (runtime polymorphism) — подкласс предоставляет свою реализацию метода суперкласса с аннотацией @Override.', 'EasyNow'),
    ('Что такое инкапсуляция в Java?', 'Инкапсуляция — это объединение данных (полей) и методов, работающих с этими данными, в одном классе, с сокрытием внутренней реализации. Достигается с помощью модификаторов доступа (private для полей) и предоставлением публичных геттеров/сеттеров. Это защищает данные от некорректного использования, упрощает поддержку кода и повышает безопасность.', 'EasyNow'),
    ('Что такое абстракция в Java?', 'Абстракция — это процесс скрытия сложных деталей реализации и показа только необходимого интерфейса. В Java реализуется через абстрактные классы (abstract class) и интерфейсы (interface). Пользователь работает только с объявленными методами, не зная, как они реализованы внутри, что упрощает использование и поддержку кода.', 'EasyNow'),
    ('Что такое конструктор в Java и для чего он нужен?', 'Конструктор — это специальный метод, который вызывается автоматически при создании объекта с помощью new. Он имеет то же имя, что и класс, не возвращает значение и используется для инициализации полей объекта. Может быть перегружен, иметь параметры и вызывать другие конструкторы через this() или super().', 'EasyNow'),
    ('Что происходит, если в классе нет конструктора?', 'Если в классе не объявлен ни один конструктор, компилятор Java автоматически создаёт конструктор по умолчанию (default constructor) без параметров, который просто вызывает конструктор суперкласса (super()). Если же вы объявили хотя бы один конструктор, default больше не создаётся, и вы должны сами обеспечить нужные варианты инициализации.', 'EasyNow'),
    ('Что такое перегрузка методов в Java?', 'Перегрузка методов (method overloading) — это наличие в одном классе нескольких методов с одинаковым именем, но разными списками параметров (количество, тип или порядок). Решение, какой метод вызвать, принимается на этапе компиляции (compile-time polymorphism). Удобно для предоставления разных способов выполнения похожей операции.', 'EasyNow'),
    ('Что такое переопределение методов в Java?', 'Переопределение методов (method overriding) — это когда подкласс предоставляет свою собственную реализацию метода, унаследованного от суперкласса. Метод должен иметь ту же сигнатуру, возвращаемый тип (или ковariantный) и аннотацию @Override. Вызов происходит на этапе выполнения (runtime polymorphism, dynamic dispatch).', 'EasyNow'),
    ('Для чего используется ключевое слово this в Java?', 'Ключевое слово this ссылается на текущий экземпляр класса. Используется для: различения полей класса и параметров метода с одинаковыми именами, вызова другого конструктора того же класса (this()), передачи текущего объекта как параметра, возврата текущего объекта из метода (return this для chain-вызовов).', 'EasyNow'),
    ('Для чего используется ключевое слово super в Java?', 'Ключевое слово super ссылается на суперкласс. Используется для: вызова конструктора суперкласса (super()), вызова переопределённого метода суперкласса (super.method()), доступа к скрытым полям суперкласса. В конструкторе подкласса super() должно быть первой строкой, если используется.', 'EasyNow'),
    ('Что такое статический метод и когда его использовать?', 'Статический метод принадлежит классу, а не конкретному объекту. Вызывается через имя класса (Class.method()), не имеет доступа к нестатическим полям и методам. Используется для утилитных операций, не зависящих от состояния объекта (например, Math.sqrt(), фабричные методы, main()).', 'EasyNow'),
    ('Что делает ключевое слово final в Java?', 'Ключевое слово final делает: переменную — константой (значение нельзя изменить после инициализации), метод — неподлежащим переопределению в подклассах, класс — неподлежащим наследованию (например, String, Integer). Повышает безопасность, позволяет оптимизации и ясно выражает намерение разработчика.', 'EasyNow'),
    ('Что такое интерфейс в Java и зачем он нужен?', 'Интерфейс — это полностью абстрактный тип, определяющий контракт (набор методов), который должен реализовать класс. С Java 8 может содержать default- и static-методы. Используется для достижения множественного наследования поведения, абстракции и слабой связанности кода (программирование к интерфейсу).', 'EasyNow'),
    ('Что такое абстрактный класс в Java?', 'Абстрактный класс — это класс, объявленный с ключевым словом abstract, который не может быть инстанцирован. Может содержать как абстрактные методы (без реализации), так и обычные методы с реализацией, поля и конструкторы. Используется как базовый класс для иерархии, когда нужно общее состояние или частичная реализация.', 'EasyNow'),
    ('В чем разница между абстрактным классом и интерфейсом?', 'Абстрактный класс может иметь состояние (поля экземпляра), конструкторы, методы с реализацией и поддерживает одиночное наследование. Интерфейс до Java 8 имел только абстрактные методы и константы, не имеет состояния, поддерживает множественную реализацию. С Java 8 интерфейсы получили default и static методы, но всё равно не имеют полей экземпляра и конструкторов.', 'EasyNow'),
    ('Что такое обработка исключений в Java?', 'Обработка исключений — это механизм реагирования на ошибки времени выполнения. Используются классы Throwable (Error и Exception), блоки try-catch-finally, ключевые слова throw (бросить исключение) и throws (объявить, что метод может бросить исключение). Позволяет грациозно обрабатывать ошибки, логировать их и продолжать работу программы.', 'EasyNow'),
    ('В чем разница между checked и unchecked исключениями?', 'Checked исключения (наследники Exception, но не RuntimeException) проверяются компилятором — метод должен либо обработать их (try-catch), либо объявить (throws). Примеры: IOException, SQLException. Unchecked (RuntimeException и её подклассы, а также Error) не требуют обязательной обработки, возникают из-за ошибок программиста (NullPointerException, ArrayIndexOutOfBoundsException).', 'EasyNow'),
    ('Для чего нужен блок try-catch в Java?', 'Блок try-catch используется для перехвата и обработки исключений. Код, который может бросить исключение, помещается в try, а обработка (логирование, восстановление) — в catch (можно несколько для разных типов). Это предотвращает аварийное завершение программы и позволяет выполнить альтернативную логику.', 'EasyNow'),
    ('Что делает блок finally в обработке исключений?', 'Блок finally выполняется всегда — независимо от того, было ли исключение, поймано оно или нет, даже при return или throw в try/catch. Обычно используется для гарантированной очистки ресурсов (закрытие файлов, соединений с БД, освобождение locks), чтобы избежать утечек.', 'EasyNow'),
    ('В чем разница между ArrayList и LinkedList?', 'ArrayList реализован на динамическом массиве: быстрый случайный доступ O(1), медленные вставка/удаление в середине O(n) из-за сдвига элементов. LinkedList — на двусвязном списке: медленный доступ O(n), быстрые вставка/удаление O(1). ArrayList лучше для чтения и больших коллекций, LinkedList — для частых изменений в середине.', 'EasyNow'),
    ('Что такое HashMap и как она работает?', 'HashMap — это реализация интерфейса Map для хранения пар ключ-значение. Использует хэш-таблицу: вычисляет hashCode() ключа, определяет индекс бакета, при коллизии использует цепочки (linked list) или деревья (с Java 8 при большом количестве). Обеспечивает среднее время операций O(1). Разрешает null в качестве ключа и значений, не синхронизирована.', 'EasyNow'),
    ('Что такое generics в Java и зачем они нужны?', 'Generics (обобщения) позволяют создавать классы, интерфейсы и методы с параметрами типов (например, List<String>). Обеспечивают проверку типов на этапе компиляции, устраняют необходимость приведения типов (casting), повышают безопасность кода и читаемость, предотвращая ClassCastException во время выполнения.', 'EasyNow'),
    ('Что такое лямбда-выражения в Java?', 'Лямбда-выражения — это анонимные функции, введённые в Java 8. Синтаксис: (параметры) -> { тело } или (параметры) -> выражение. Используются для реализации функциональных интерфейсов (с одним абстрактным методом), упрощают код, особенно при работе с коллекциями и Stream API, заменяя громоздкие анонимные классы.', 'EasyNow'),
    ('Что такое Stream API в Java?', 'Stream API (java.util.stream) — это функциональный способ обработки коллекций, введённый в Java 8. Stream представляет последовательность элементов, поддерживает промежуточные операции (map, filter, sorted) и терминальные (collect, reduce, forEach). Позволяет писать декларативный, параллелизуемый (parallelStream()) код без изменения исходной коллекции.', 'EasyNow'),
    ('Что такое garbage collection в Java?', 'Garbage collection — автоматический процесс освобождения памяти от объектов, на которые больше нет активных ссылок. GC в JVM использует generational подход (Young и Old generation), алгоритмы вроде mark-and-sweep. Разработчик не управляет памятью вручную (в отличие от C++), что предотвращает утечки и ошибки доступа.', 'EasyNow'),
    ('Что такое класс String в Java?', 'String — неизменяемый (immutable) класс для представления текста. Все строковые литералы хранятся в специальном пуле строк (String pool) для экономии памяти и быстрого сравнения. Операции вроде конкатенации создают новые объекты. Для частых изменений лучше использовать StringBuilder или StringBuffer.', 'EasyNow'),
    ('В чем разница между String, StringBuilder и StringBuffer?', 'String — immutable, thread-safe, но медленный при частых изменениях (создаёт новые объекты). StringBuilder — mutable, не синхронизирован, быстрый в однопоточной среде. StringBuffer — mutable, все методы synchronized, thread-safe, но медленнее StringBuilder.', 'EasyNow'),
    ('Что такое сериализация в Java?', 'Сериализация — процесс преобразования объекта в последовательность байтов для сохранения на диск, передачи по сети или кэширования. Класс должен реализовывать маркерный интерфейс Serializable. Поля с transient или static не сериализуются. Управляется ObjectOutputStream.', 'EasyNow'),
    ('Что такое десериализация в Java?', 'Десериализация — обратный процесс сериализации: восстановление объекта из байтового потока с сохранением состояния. Выполняется ObjectInputStream.readObject(). Может вызвать исключения, если класс изменился (InvalidClassException) или отсутствует.', 'EasyNow'),
    ('Что такое enum в Java?', 'Enum — специальный тип класса для представления фиксированного набора констант (например, дни недели, статусы заказа). Введён в Java 5. Элементы enum — статические объекты типа самого enum, могут иметь поля, методы и конструкторы. Типобезопасны, поддерживают switch и сравнение.', 'EasyNow'),
    ('В чем разница между Comparable и Comparator?', 'Comparable — интерфейс, реализуемый внутри класса для естественного порядка сортировки (метод compareTo). Один на класс. Comparator — внешний интерфейс для кастомной сортировки (метод compare), можно создавать несколько разных компараторов для одного класса.', 'EasyNow'),
    ('Что такое TreeSet в коллекциях Java?', 'TreeSet — реализация интерфейса Set на основе красно-чёрного дерева (Red-Black Tree). Хранит элементы в отсортированном порядке (по Comparable или предоставленному Comparator), не допускает дубликатов, операции O(log n). Не сохраняет порядок вставки.', 'EasyNow'),
    ('Что такое функциональный интерфейс в Java?', 'Функциональный интерфейс — интерфейс с ровно одним абстрактным методом (SAM — Single Abstract Method). Может иметь default и static методы. Аннотация @FunctionalInterface для проверки. Используется для лямбда-выражений и метод-ссылок (Runnable, Consumer, Function, Predicate и др.).', 'EasyNow'),
    ('Что такое try-with-resources в Java?', 'Try-with-resources (с Java 7) — конструкция для автоматического закрытия ресурсов, реализующих AutoCloseable или Closeable (файлы, сокеты, БД). Синтаксис: try (Resource r = new Resource()) { ... }. Гарантирует вызов close() в finally, даже при исключении, упрощая код и предотвращая утечки.', 'EasyNow'),
    ('Что такое анонимный внутренний класс?', 'Анонимный внутренний класс — безымянный класс, создаваемый на лету для одноразовой реализации интерфейса или расширения класса. Часто использовался до Java 8 для слушателей событий, обработчиков и т.д. Синтаксис: new Interface() { ... реализация ... }.', 'EasyNow'),
    ('Что такое CompletableFuture в Java?', 'CompletableFuture (с Java 8) — мощный класс для асинхронного программирования. Наследует Future, но позволяет цепочечно комбинировать задачи (thenApply, thenCompose, thenCombine, whenComplete), обрабатывать результаты и исключения без явного управления потоками. Упрощает неблокирующий код.', 'EasyNow'),
    ('Что такое Javadoc и как его использовать?', 'Javadoc — инструмент для генерации HTML-документации из специальных комментариев /** ... */ в коде. Использует теги @param, @return, @throws, @author, @since, @see и др. Запускается командой javadoc. Стандартный способ документирования API в Java, особенно в публичных библиотеках и интерфейсах.', 'EasyNow'),
    ('Что такое модификаторы доступа в Java?', 'Модификаторы доступа контролируют видимость членов класса: public — доступен везде; protected — в пакете и подклассах; default (без модификатора) — только в пакете (package-private); private — только внутри класса. Обеспечивают инкапсуляцию и безопасность кода.', 'EasyNow'),
    ('Что такое autoboxing и unboxing в Java?', 'Autoboxing — автоматическое преобразование примитивного типа в соответствующий объект-обёртку (int → Integer). Unboxing — обратное (Integer → int). Введено в Java 5 для удобства работы с коллекциями и generics, которые не поддерживают примитивы.', 'EasyNow'),
    ('Что такое классы-обертки в Java?', 'Классы-обёртки (wrapper classes) — Immutable классы, оборачивающие примитивные типы: Integer для int, Double для double, Boolean для boolean и т.д. Предоставляют методы утилит (parseInt, valueOf), кэширование маленьких значений и необходимы для использования примитивов в коллекциях и generics.', 'EasyNow'),
    ('Что предоставляет класс Math в Java?', 'Math — утилитный класс со статическими математическими константами (PI, E) и методами: abs, sin, cos, tan, pow, sqrt, log, min/max, round, floor, ceil, random() и др. Все методы точны, оптимизированы и не требуют создания объекта.', 'EasyNow'),
    ('Для чего класс Runtime в Java?', 'Runtime — singleton-класс для взаимодействия с JVM. Позволяет запускать внешние процессы (exec()), получать информацию о памяти (freeMemory(), totalMemory()), вызывать garbage collection (gc()), завершать приложение (exit(), halt()). Получается через Runtime.getRuntime().', 'EasyNow'),
    ('Иерархия коллекций в Java. Основные интерфейсы', 'Java Collections Framework — это иерархия интерфейсов и классов для работы с группами объектов. Основные интерфейсы: Collection (корневой, содержит базовые методы add, remove, size, contains и т.д.), List (упорядоченная коллекция с дубликатами, доступ по индексу), Set (множество без дубликатов), Queue (очередь для обработки в определённом порядке), Deque (двусторонняя очередь). От Collection также отходит Map (не наследует Collection, но относится к фреймворку; хранит пары ключ-значение). Популярные реализации: ArrayList (List), HashSet/TreeSet/LinkedHashSet (Set), HashMap/TreeMap/LinkedHashMap (Map). Иерархия позволяет программировать к интерфейсам, легко менять реализации.', 'EasyNow'),
    ('Зачем нужны equals() и hashCode()? Контракт между ними', 'Метод equals() определяет логическое равенство двух объектов (по содержимому, а не по ссылке). По умолчанию (из Object) сравнивает ссылки (==). hashCode() возвращает целочисленный хэш-код объекта для эффективного использования в хэш-структурах (HashMap, HashSet). Контракт (из документации Object): 1) Если equals() возвращает true для двух объектов, их hashCode() должен быть одинаковым. 2) Если hashCode() одинаковый, equals() может возвращать false (коллизия). 3) hashCode() должен быть консистентным: при неизменном состоянии объекта возвращать один и тот же значение. Переопределять нужно оба метода вместе, иначе коллекции на хэшах будут работать некорректно (объекты могут ''потеряться'').', 'EasyNow'),
    ('Для чего нужны functional interfaces? (Predicate, Consumer, Function, Supplier)', 'Functional interfaces — интерфейсы с одним абстрактным методом (SAM), используются как цель для лямбда-выражений и метод-ссылок в функциональном программировании Java 8+. Основные из java.util.function: Predicate<T> — принимает T, возвращает boolean (для фильтрации, test()); Consumer<T> — принимает T, ничего не возвращает (для действий, accept()); Function<T,R> — принимает T, возвращает R (для преобразования, apply()); Supplier<T> — ничего не принимает, возвращает T (для создания объектов, get()). Они упрощают код при работе со Stream API, коллекциями (forEach, filter, map) и делают его более выразительным и кратким.', 'EasyNow'),
    ('Что такое Stack и Heap память и для чего нужна?', 'В JVM память делится на области. Stack (стек) — используется для хранения локальных переменных, параметров методов, ссылок на объекты и вызовов методов (фреймы стека). Каждый поток имеет свой стек. Быстрая, автоматическая очистка при выходе из метода. Heap (куча) — общая область для всех потоков, где хранятся объекты и массивы (созданные через new). Управляется garbage collector''ом. Большая, но медленнее стека. Примитивы могут храниться в стеке (локальные), объекты — всегда в heap. Деление обеспечивает эффективное управление памятью и многопоточность.', 'EasyNow'),
    ('Почему лучше использовать примитивы, а не обёртки, где возможно?', 'Примитивы (int, double, boolean) хранятся напрямую (значение), обёртки (Integer, Double, Boolean) — объекты в heap с overhead (дополнительная память на объект, ссылку). Примитивы быстрее (нет боксинга/анбоксинга, лучше кэшируются), потребляют меньше памяти, не могут быть null (избегают NPE). Обёртки нужны только когда требуется объект: в коллекциях (List<int> невозможно, только List<Integer>), generics, null-значения или методы утилит. В современном Java (с autoboxing) разница меньше, но в высоконагруженном коде и циклах примитивы дают заметный прирост производительности.', 'EasyNow'),
    ('Можно ли в одном catch ловить несколько исключений?', 'Да, с Java 7 введён multi-catch: catch (IOException | SQLException | MyException e) { ... }. Позволяет обработать несколько типов исключений одним блоком, если логика обработки одинакова. Исключения должны быть взаимно исключающими (не наследоваться друг от друга), иначе ошибка компиляции. Упрощает код, уменьшает дублирование и делает его чище. Переменная e final (нельзя переприсвоить).', 'EasyNow'),
    ('Разница между HashSet, TreeSet и LinkedHashSet', 'Все реализуют Set (без дубликатов). HashSet — на хэш-таблице, быстрые операции O(1), не сохраняет порядок вставки, допускает один null. TreeSet — на красно-чёрном дереве, элементы отсортированы (по Comparable или Comparator), операции O(log n), не допускает null (NPE). LinkedHashSet — на хэш-таблице + связном списке, сохраняет порядок вставки, чуть медленнее HashSet, допускает null. Выбор: HashSet — для максимальной скорости, TreeSet — для сортировки, LinkedHashSet — для предсказуемого порядка итерации.', 'EasyNow'),
    ('Как работает HashMap? Что такое коллизии?', 'HashMap хранит пары ключ-значение в массиве бакетов. При put(): вычисляется hashCode() ключа, хэш % размер массива даёт индекс бакета. Если бакет пуст — создаётся Entry (ключ, значение, хэш, ссылка на следующий). Если занят — коллизия. До Java 8 коллизии решались цепочкой (linked list), с Java 8 при длине цепочки > 8 превращается в красно-чёрное дерево для O(log n). get() аналогично ищет по хэшу и equals(). Load factor 0.75 — при заполнении массив ресайзится (вдвое). Коллизия — когда разные ключи дают один индекс бакета (из-за хэша). Хороший hashCode() минимизирует коллизии.', 'EasyNow');
